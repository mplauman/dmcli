use std::time::{Duration, SystemTime};

/// A unique identifier for a message in a conversation
///
/// # Fields
///
/// * `conversation` - The system time when the conversation started
/// * `timestamp` - The duration since the conversation start when this message was created
pub struct Id {
    conversation: SystemTime,
    timestamp: Duration,
}

impl std::fmt::Display for Id {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let timestamp = self
            .conversation
            .checked_add(self.timestamp)
            .expect("time is reasonable");

        write!(f, "{timestamp:?}")
    }
}

/// Defines different roles that a message can have in a conversation
///
/// # Variants
///
/// * `User` - Messages that are sent to the LLM as part of its conversation
/// * `Assistant` - Responses generated by the agent/LLM
/// * `Thinking` - Messages that are sent to the LLM as part of its conversation
/// * `System` - Responses generated by built-in commands
/// * `Error` - Messages that are sent to the LLM as part of its conversation
enum Role {
    User,
    Assistant,
    Thinking,
    System,
    Error,
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Role::User => write!(f, "user"),
            Role::Assistant => write!(f, "assistant"),
            Role::Thinking => write!(f, "thinking"),
            Role::System => write!(f, "system"),
            Role::Error => write!(f, "error"),
        }
    }
}

/// A message in a conversation
///
/// # Fields
///
/// * `id` - A unique identifier for this message
/// * `role` - The role of this message in the conversation
/// * `content` - The content of the message, which can be:
///   - Human readable text
///   - Encoded binary data
///   - JSON or other structured data
///   - Any other string-encoded data format
pub struct Message {
    id: Id,
    role: Role,
    content: String,
}

impl std::fmt::Display for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} {}: {}", self.id, self.role, self.content)
    }
}

/// Represents a sequence of messages in an ongoing conversation
///
/// A conversation is a collection of messages with different roles (user, assistant, system etc.)
/// that are created in sequential order. Each message is timestamped relative to when the
/// conversation started.
///
/// # Example
///
/// ```
/// let mut conversation = Conversation::default();
///
/// // Add a user message
/// conversation.user("What is the capital of France?");
///
/// // Add an assistant response
/// conversation.assistant("The capital of France is Paris.");
///
/// // Add a system message
/// conversation.system("`[4] = **4**");
/// ```
pub struct Conversation {
    id: SystemTime,
    messages: Vec<Message>,
}

impl Conversation {
    pub fn user(&mut self, content: impl Into<String>) {
        self.append(Role::User, content);
    }

    pub fn assistant(&mut self, content: impl Into<String>) {
        self.append(Role::Assistant, content);
    }

    pub fn system(&mut self, content: impl Into<String>) {
        self.append(Role::System, content);
    }

    pub fn thinking(&mut self, content: impl Into<String>) {
        self.append(Role::Thinking, content);
    }

    pub fn error(&mut self, content: impl Into<String>) {
        self.append(Role::Error, content);
    }

    fn append(&mut self, role: Role, content: impl Into<String>) {
        let id = Id {
            conversation: self.id,
            timestamp: SystemTime::now()
                .duration_since(self.id)
                .expect("timestamp math works"),
        };
        let content = content.into();
        let message = Message { id, role, content };

        self.messages.push(message);
    }
}

impl Default for Conversation {
    fn default() -> Self {
        Self {
            id: SystemTime::now(),
            messages: Vec::new(),
        }
    }
}
